# Level_1
Уровень 1

## Решение устных задач

Какой самый эффективный способ конкатенации строк?
---
strings.Builder используется для эффективного добавления строк с использованием методов записи.

- Он предлагает подмножество методов bytes.Buffer, что позволяет безопасно избежать дополнительного копирования при преобразовании Builder в строку.
- Вы можете использовать пакет fmt для форматирования, поскольку Builder реализует интерфейс io.Writer.
- Метод Grow может использоваться для предварительного выделения памяти, когда известен максимальный размер строки.

var b strings.Builder
b.Grow(32)
for i, p := range []int{2, 3, 5, 7, 11, 13} {
    fmt.Fprintf(&b, "%d:%d, ", i+1, p)
}
s := b.String()   // нет копирования

s = s[:b.Len()-2] // нет копирования 
                  // (удаляет завершающий ", ")
fmt.Println(s)

- Для простых случаев, когда производительность не является проблемой, fmt.Sprintf - ваш друг. Это чисто, просто и довольно эффективно.


s := fmt.Sprintf("Size: %d MB.", 85) // s == "Size: 85 MB."


Что такое интерфейсы, как они применяются в Go?
---
Интерфейсы — это инструменты для определения наборов действий и поведения. Они позволяют объектам опираться на абстракции, а не фактические реализации других объектов. При этом для компоновки различных поведений можно группировать несколько интерфейсов

- Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода.
- Они облегчают использование в модульных тестах заглушек вместо реальных объектов.
- Будучи архитектурным инструментом, интерфейсы помогают отвязывать части вашей кодовой базы.

Чем отличаются RWMutex от Mutex?
---
RWMutex позволят выборочно блокировать либо запись, либо чтение, но при блокировки на чтение к примеру нельзя разблокировать общим методом,
а нужно применять именно разблокировку чтения

Mutex блокирует запись и чтение одновременно 

Чем отличаются буферизированные и не буферизированные каналы?
---
В буферещированном надо указывать размер буфера при обьявлении и при работе пока буфер не заполниться данные из канала получить нельзя

Небуферизированный объявляется без указания размера буфера и получить данные можно моментально

Какой размер у структуры struct{}{}?
---
По идее 0 байт, конечно же есть накладные расходы на ее объявление, хранение указателя, ссылки и т.п. Так что это совсем не 'ничего', но использование struct{} имеет наименьшее потребление памяти

Так что думаю до 1байт весит struct{}{}

Есть ли в Go перегрузка методов или операторов?
---
Go до сих пор нет перегруженных функций (и, вероятно, никогда не будет), наиболее полезная функция перегрузки — вызов функции с необязательными аргументами и вывод значений по умолчанию для тех, которые опущены, — может быть смоделирована с помощью функции с переменным числом аргументов, которая с тех пор была добавлена.

В какой последовательности будут выведены элементы map[int]int?
---

Пример:
m[0]=1
m[1]=124
m[2]=281

Ответ: В рандомном, если надо структурировать, то можно воспользоваться функцией 

В чем разница make и new?
---
'new' возвращает указатель вместо значения возвращаемое функцией 'make'
'make' имеет вариадический аргумент 'size'
'make' выделяет память и инциализирует только объекты типов: slice, map, or chan

Сколько существует способов задать переменную типа slice или map?
---
По идеи 3 способа в зависимсти от удобства, более хорошим считается с использованием make
var s []byte
s:= []byte
s = make([]byte, 5, 5)


Что выведет данная программа и почему?


func update(p *int) {
  b := 2
  p = &b
}


func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
Данная программа выедет два раза 1, потому что мы функцией update записываем в новую переменную значение, а не обращаемся к ней по ссылке

Что выведет данная программа и почему?
---

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

Скорее всего эта прогамма выдаст дедлок, потому что мы передаем в рутину копию Ваит групп, и наш обьявленный вайтгрупп,
никогда не даждется зарвершения рутин
Исправить можно так:
func main() {
	wg := sync.WaitGroup{}

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(&wg, i)

	}
	wg.Wait()
	fmt.Println("exit")
}

Или вообще убрать:

func main() {
	wg := sync.WaitGroup{}

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func( i int) {
			fmt.Println(i)
			wg.Done()
		}(i)

	}
	wg.Wait()
	fmt.Println("exit")
}

Что выведет данная программа и почему?
---

func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}

Ответ: 0, условие не будет выполнено, оно неоднозначно

Что выведет данная программа и почему?
---

func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

Ответ: Думаю что данный принт распчатает [100 2 3 4 5], так как при создание среза у нас создается массив определенной величины,
а когда мы пытаемся добавить еще больше, создается новый массив. Таким образом, возвращаемый фрагмент может ссылаться на другой базовый массив

вот так мы можем получить наш новый массив:
func someAction(v []int8, b int8) []int8 {
	v[0] = 100
	v = append(v, b)
	fmt.Println(v)
	return v
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	a = someAction(a, 6)
	fmt.Println(a)
}

Что выведет данная программа и почему?
---

func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

Ответ: [b b a][a a] Так ка мы как и в предыдущем примере увеличили размер массива, то создался новый, а в страом поменялись значания, которые подходят по длине


